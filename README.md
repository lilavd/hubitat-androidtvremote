# hubitat-androidtvremote-conversion
An attempt to use an AI tool to convert (and accelerate development) drivers suitable for use in Hubitat.  The following README content was generated by the AI tool.  The AI tool used was claude.ai


# Android TV Remote - Hubitat Driver

## Overview

This Hubitat driver implements the Android TV Remote Protocol v2, which is the same protocol used by the Google TV mobile app. It allows you to control Android TV devices from Hubitat without requiring ADB (Android Debug Bridge) or developer mode on the TV.

**Based on:**
- Home Assistant's Android TV Remote integration
- androidtvremote2 Python library by tronikos
- Android TV Remote Protocol v2 specification

## Important Limitations

### **CRITICAL: Protocol Implementation Constraints**

This driver provides a **conceptual framework** for Android TV Remote control, but has significant technical limitations due to Hubitat's Groovy environment:

1. **No Native Protocol Buffer Support**: The Android TV Remote Protocol v2 uses Google Protocol Buffers (protobuf) for message serialization. Hubitat's Groovy environment doesn't have native protobuf support.

2. **No Persistent SSL/TLS Connections**: The protocol requires persistent SSL/TLS socket connections with mutual certificate authentication. Hubitat's HTTP client doesn't support persistent bidirectional socket connections.

3. **No Certificate Generation**: While the driver includes placeholder code for certificate generation, creating proper X.509 certificates with the correct extensions for the Android TV protocol is not fully supported in Hubitat's sandbox.

### Recommended Solutions

For full Android TV Remote Protocol v2 functionality, consider these alternatives:

#### Option 1: Bridge Service (Recommended)
Use this driver as a reference and implement the actual protocol in a bridge service:

**Node-RED Bridge:**
- Install Node-RED
- Use the `node-red-contrib-androidtvremote2` node
- Create flows that expose HTTP endpoints
- Have this Hubitat driver call those endpoints

**Home Assistant Bridge:**
- Set up Home Assistant with Android TV Remote integration
- Use Hubitat's Home Assistant integration or Maker API
- Control TV through Home Assistant

**Python Bridge:**
- Run a simple Python script using `androidtvremote2` library
- Expose REST API endpoints
- Call from Hubitat

#### Option 2: ADB-Based Alternative
If you enable developer mode on your Android TV:
- Use the existing `python-androidtv` approach
- Requires ADB debugging enabled
- More complex but works directly

#### Option 3: IR/RF Control
- Use IR blaster or RF remote integration
- Most reliable but limited to basic commands
- No feedback from TV

## Features (If Bridge Implemented)

### Capabilities
- Switch (Power On/Off)
- Switch Level (Volume Control)
- Media Controller (Play, Pause, Stop, etc.)
- Refresh
- Initialize

### Commands

#### Navigation
- `dpadUp()`, `dpadDown()`, `dpadLeft()`, `dpadRight()`
- `dpadCenter()`, `back()`, `home()`, `menu()`

#### Media Control
- `play()`, `pause()`, `playPause()`, `stop()`
- `fastForward()`, `rewind()`
- `skipForward()`, `skipBackward()`

#### Volume
- `volumeUp()`, `volumeDown()`
- `mute()`, `unmute()`
- `setVolume(level)` - Set volume 0-100

#### Power
- `powerOn()`, `powerOff()`, `powerToggle()`
- `sleep()`, `wakeUp()`

#### Apps
- `launchApp(url)` - Launch app with deep link
- `sendText(text)` - Send keyboard input

#### Connection
- `connect()`, `disconnect()`
- `startPairing()`, `completePairing(code)`

### Attributes
- `power` - on/off
- `volume` - 0-100
- `muted` - muted/unmuted
- `currentApp` - Current application name
- `connectionStatus` - connected/disconnected/connecting/error
- `paired` - true/false/pairing/unknown
- `lastActivity` - Last command sent

## Installation

1. **Copy Driver Code**
   - In Hubitat web interface, go to **Drivers Code**
   - Click **New Driver**
   - Paste the driver code
   - Click **Save**

2. **Create Virtual Device**
   - Go to **Devices**
   - Click **Add Device**
   - Click **Virtual**
   - Fill in device details
   - Select **Android TV Remote** as Type
   - Click **Save Device**

3. **Configure Device**
   - Enter your Android TV's IP address
   - Adjust port if needed (default: 6466)
   - Set device name for pairing
   - Configure auto-connect and reconnect options
   - Save preferences

## Pairing Process

### Initial Pairing

1. **Start Pairing**
   ```
   Click "startPairing" command
   ```

2. **Get Code from TV**
   - A 6-digit code should appear on your Android TV screen
   - If not, check:
     - Android TV Remote Service is installed
     - TV is on the same network
     - Firewall isn't blocking port 6466

3. **Complete Pairing**
   ```
   completePairing("123456")  // Use the code from your TV
   ```

4. **Success**
   - Driver will save pairing credentials
   - Auto-connect if enabled

### Re-Pairing
If you need to re-pair:
1. Clear pairing data from TV:
   - Settings → Apps → Android TV Remote Service
   - Clear data and cache
2. Run `startPairing()` again

## Using with Bridge Service

### Example: Node-RED Bridge

**Node-RED Flow:**
```json
[
  {
    "id": "androidtv1",
    "type": "androidtvremote2",
    "name": "Living Room TV",
    "host": "192.168.1.100",
    "credentials": "..."
  },
  {
    "id": "http-in",
    "type": "http in",
    "url": "/androidtv/command",
    "method": "post"
  },
  {
    "id": "process",
    "type": "function",
    "func": "msg.payload = { keyCode: msg.payload.keyCode }; return msg;",
    "outputs": 1
  },
  {
    "id": "send-command",
    "type": "androidtvremote2-send",
    "tv": "androidtv1"
  }
]
```

**Modify Driver Methods:**
```groovy
private sendKeyCommand(int keyCode, String keyName) {
    def params = [
        uri: "http://your-nodered-ip:1880/androidtv/command",
        contentType: "application/json",
        body: [
            keyCode: keyCode,
            device: deviceIP
        ]
    ]
    
    try {
        httpPost(params) { resp ->
            if (resp.status == 200) {
                sendEvent(name: "lastActivity", value: keyName)
                return true
            }
        }
    } catch (Exception e) {
        log.error "Failed to send command: ${e.message}"
    }
}
```

### Example: Python Bridge

**Python Script (bridge.py):**
```python
from flask import Flask, request
from androidtvremote2 import AndroidTVRemote
import asyncio

app = Flask(__name__)
tv = None

@app.route('/connect', methods=['POST'])
async def connect():
    global tv
    data = request.json
    tv = AndroidTVRemote(data['host'], data['cert'], data['key'])
    await tv.async_connect()
    return {'status': 'connected'}

@app.route('/key', methods=['POST'])
async def send_key():
    data = request.json
    await tv.async_send_key(data['keyCode'])
    return {'status': 'sent'}

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
```

## App Deep Links

Use `launchApp(url)` with these deep link formats:

### Popular Apps

**Netflix:**
```groovy
launchApp("https://www.netflix.com/title/80057281")  // Specific title
```

**YouTube:**
```groovy
launchApp("vnd.youtube://www.youtube.com/watch?v=dQw4w9WgXcQ")
```

**Plex:**
```groovy
launchApp("plex://")
```

**Spotify:**
```groovy
launchApp("spotify://")
```

**Disney+:**
```groovy
launchApp("https://www.disneyplus.com/video/...")
```

### Finding Deep Links

1. **Android Debug Bridge (ADB):**
   ```bash
   adb shell dumpsys package | grep -A 3 "android.intent.action.VIEW"
   ```

2. **Community Resources:**
   - Home Assistant Deep Link Guide
   - Reddit r/AndroidTV
   - XDA Developers forums

## Automation Examples

### Rule Machine Examples

**Morning Routine:**
```groovy
// Turn on TV and launch YouTube
androidTV.powerOn()
delay(5000)
androidTV.launchApp("vnd.youtube://")
```

**Volume Control by Time:**
```groovy
if (time.hour < 8 || time.hour > 22) {
    androidTV.setVolume(20)  // Quiet hours
} else {
    androidTV.setVolume(50)  // Normal volume
}
```

**Mute During Calls:**
```groovy
// When phone rings
androidTV.mute()

// When call ends
androidTV.unmute()
```

### Mode-Based Control

```groovy
if (location.mode == "Movie") {
    androidTV.powerOn()
    delay(3000)
    androidTV.launchApp("plex://")
    androidTV.setVolume(60)
}
```

## Troubleshooting

### TV Not Responding

1. **Check Connection:**
   - Verify TV is powered on
   - Confirm IP address is correct
   - Check same network/VLAN

2. **Check Service:**
   - Android TV Remote Service must be installed
   - On TV: Settings → Apps → Show system apps
   - Find "Android TV Remote Service"
   - Should be enabled

3. **Network Issues:**
   - Port 6466 must be open
   - Check firewall rules
   - Try disabling AP isolation

4. **Re-Pair:**
   - Clear TV's Remote Service data
   - Run `startPairing()` again

### Pairing Fails

1. **No Code Appears:**
   - TV might not support Remote Protocol v2
   - Check Android TV version (need 2015+ models)
   - Fire TV devices NOT supported

2. **Invalid Code Error:**
   - Code must be exactly 6 digits
   - Enter within timeout period (~60 seconds)
   - Try startPairing() again

3. **Certificate Errors:**
   - Due to Hubitat limitations
   - Use bridge service instead

### Commands Not Working

1. **Connection Status:**
   - Check `connectionStatus` attribute
   - Should show "connected"
   - Try `connect()` command

2. **Protocol Limitations:**
   - Remember: full protocol needs bridge
   - Check bridge service is running
   - Verify bridge logs

## Advanced Configuration

### Preferences

| Setting | Default | Description |
|---------|---------|-------------|
| Device IP | - | Android TV IP address (required) |
| Port | 6466 | Android TV Remote Service port |
| Device Name | Hubitat | Name shown on TV during pairing |
| Auto-connect | true | Connect automatically on initialize |
| Auto-reconnect | true | Reconnect if connection lost |
| Reconnect Delay | 30 | Seconds to wait before reconnecting |
| Refresh Interval | 60 | Seconds between status checks (0=disabled) |
| Debug Logging | true | Enable detailed logging |
| Description Logging | true | Enable event descriptions |

### Finding TV IP Address

**Method 1 - TV Settings:**
1. Settings → Network → Network Status
2. Note the IP address

**Method 2 - Router:**
1. Access router admin panel
2. Find connected devices
3. Look for TV by name/MAC

**Method 3 - Network Scan:**
```bash
nmap -p 6466 192.168.1.0/24
```

### Static IP Recommendation

Set static IP for your Android TV:
1. TV Settings → Network
2. Choose your network
3. Advanced Settings
4. IP Settings → Static
5. Enter IP, gateway, DNS

## Protocol Details

### Android TV Remote Protocol v2

**Technology Stack:**
- Transport: TLS 1.2+ over TCP
- Port: 6466 (default)
- Messages: Google Protocol Buffers
- Authentication: Mutual TLS with certificates

**Message Types:**
- Remote key injection (key codes)
- App link launch (deep links)
- IME key injection (text input)
- Voice command (PCM audio)
- Configuration
- Ping/Pong

**Pairing Process:**
1. Client generates RSA 2048-bit key pair
2. Client creates self-signed X.509 certificate
3. Client sends pairing request with certificate
4. TV displays 6-digit code
5. Client sends code for verification
6. TV stores certificate as trusted
7. Future connections use mutual TLS

### Key Codes Reference

Full list at: `KEY_CODES` map in driver

Common codes:
- Navigation: 19-23
- Media: 85-90, 126-127
- Volume: 24-25, 164
- Power: 26, 223-224

## Comparison with Other Drivers

### vs. Philips TV Driver

**Philips TV (included):**
- Uses JointSpace API
- HTTP/HTTPS REST calls
- Philips-specific features (Ambilight)
- No pairing required (just auth)
- **Works natively in Hubitat**

**Android TV Remote:**
- Uses Remote Protocol v2
- Protobuf over TLS
- Standard Android TV features
- Requires pairing
- **Needs bridge for full functionality**

### vs. ADB-Based Control

**ADB Approach:**
- Requires developer mode
- Direct ADB commands
- No pairing process
- More complex setup
- Works for Fire TV

**Remote Protocol v2:**
- No developer mode needed
- User-friendly pairing
- Official protocol
- Does NOT work for Fire TV
- Simpler for end users

## Support & Resources

### Documentation
- [Home Assistant Android TV Remote](https://www.home-assistant.io/integrations/androidtv_remote/)
- [androidtvremote2 Library](https://github.com/tronikos/androidtvremote2)
- [Protocol v2 Description](https://github.com/Aymkdn/assistant-freebox-cloud/wiki/Google-TV-(aka-Android-TV)-Remote-Control-(v2))

### Community
- Hubitat Community Forums
- Home Assistant Community
- Reddit r/Hubitat
- Reddit r/AndroidTV

### Related Projects
- [Node-RED Android TV](https://flows.nodered.org/node/node-red-contrib-androidtv)
- [python-androidtv (ADB)](https://github.com/JeffLIrion/python-androidtv)
- [Android TV Remote Cards](https://github.com/pathofleastresistor/polr-android-tv-remote-card)

## License

Apache License 2.0

## Contributing

This driver is part of the Hubitat community drivers project. Contributions welcome:

1. Fork the repository
2. Create feature branch
3. Test thoroughly
4. Submit pull request

## Disclaimer

This is an unofficial driver not affiliated with Google, Android TV, or Hubitat. Use at your own risk. The driver may not work without additional bridge services due to platform limitations.

## Version History

### v1.0.0 (2025-02-08)
- Initial release
- Basic protocol framework
- Pairing implementation (conceptual)
- Command structure
- Bridge service recommendations
- Full documentation

## FAQ

**Q: Why doesn't this work out of the box?**
A: Hubitat's Groovy environment lacks native support for Protocol Buffers and persistent TLS connections required by Android TV Remote Protocol v2. A bridge service is needed.

**Q: What's the easiest way to get this working?**
A: Set up Node-RED with the `node-red-contrib-androidtvremote2` node, or use Home Assistant's Android TV Remote integration as a bridge.

**Q: Does this work with Fire TV?**
A: No, Fire TV devices don't support Android TV Remote Protocol v2. Use ADB-based control instead.

**Q: Can I control multiple TVs?**
A: Yes, create separate virtual devices for each TV with different IP addresses.

**Q: Is this better than IR control?**
A: Yes, when working properly:
- Bidirectional communication
- No line-of-sight needed
- App launching capability
- Text input support
- Status feedback

**Q: Why include this driver if it needs a bridge?**
A: It provides:
- Correct protocol structure
- Complete command reference
- Pairing implementation guide
- Foundation for custom solutions
- Documentation of capabilities

## Acknowledgments

- **tronikos** - androidtvremote2 Python library
- **Home Assistant Team** - Android TV Remote integration
- **Hubitat Community** - Testing and feedback
- **Android TV Team** - Protocol specification
- **louis49** - Original protocol reverse engineering

